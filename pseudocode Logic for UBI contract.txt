Logic for UBI contract

ERC20 Beans
ERC721 BeanX
//!!!!!!!! owned
//this contract needs to be owned, and interfaces to BEANS and BEANX contracts referenced to address
//we need to implement messaging 

address beansAddress = xxxxxx;
address beanxAddress = xxxxxx;

//!!!!!make functions to set beans / beanx adresses using owned (onlyOwner?)


!!!!!!!!!!!!!! use safemath for all math !!!!!!!!!!!!!!

!!!! see https://solidity.readthedocs.io/en/v0.4.24/common-patterns.html for details on send vs withdraw ... we will have to implement the withdraw pattern instead of send. 
 
 
 //-----------------------Crappy-ass pseudocode follows
 
 import "./Ownable.sol";
 import "./Safemath.sol";

contract distribute_beans is Ownable {

    using SafeMath for uint256;
    using SafeMath32 for uint32;
    using SafeMath16 for uint16;

    mapping (uint256 => uint) ubiDate ; //key is the ERC721 tokenID, value is a date  
    mapping (address => uint) pendingWithdrawals;

    
    function UBI_distribute public (uint256 tokenId){  
    
        if(ERC721BEANX_ownerOf(tokenId) == msg.sender){   //call to a non-extant interface to beans contract //FAKE CODE
        
            if (ubiDate[tokenId] != 0){
                uint256 ubiamount = div (balanceOf(this_contract) , 1800);  //FAKE CODE now with safemath!

                if (ubiamount > 50) {
                    ubiamount = 50;
                }

                ubiBeans = (now - ubiDate) * ubiamount;  //all must be normalized to days!!!!! //FAKE CODE
                pendingWithdrawals[msg.sender] += ubiBeans;   //could also be: 
                                                              //pendingWithdrawals[ERC721BEANX_ownerOf(tokenId)] += ubiBeans; 
                                                              
                return message "beancoin distribution success " + ubibeans + " withdrawable for " + msg.sender; //FAKE CODE
                
            } else {
                ubiDate[tokenId] = now;
                return message "beancoin UBI initialized " + now + " for beanx " + tokenId; //FAKE CODE
            }

        } else {
            return message "BeanX token not found at address" +  msg.sender; //FAKE CODE
        }

    }


    function UBI_withdraw() public {
    
        uint amount = pendingWithdrawals[msg.sender];
        
        // Remember to zero the pending refund before
        // sending to prevent re-entrancy attacks
        
        pendingWithdrawals[msg.sender] = 0;
        
        transfer_beans(msg.sender, amount);    //call to a non-extant interface to beans contract //FAKE CODE
                                                //This contract must hold the beans to distribute?
    }  

    function setBeansAddress onlyOwner public (address contractAddress){  //order of modifiers?
        require(contractAddress != 0, "Invalid contract address");
        beansAddress = contractAddress;  
    }

    function setBeanxAddress onlyOwner public  (address contractAddress){
        require(contractAddress != 0, "Invalid contract address");
        beanxAddress = contractAddress;  
    }

    
}
